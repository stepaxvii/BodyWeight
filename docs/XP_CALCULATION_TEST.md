# Тестирование расчёта XP

## Проблема
Пользователь сообщает, что XP начисляется неправильно:
- Первый подход может добавить 30 XP
- Последующие подходы добавляют только 1 XP или 0
- Проверялось на L-сидении

## Текущая логика (Backend)

### L-сидение (l-sit)
- `base_xp = 15`
- `difficulty = 4`
- `is_timed = true`
- `difficulty_mult = 1 + (4-1) × 0.25 = 1.75`

### Пример расчёта (текущая логика)

**Сценарий 1: 1 подход, 30 секунд**
```
total_duration = 30
xp_value = 30 // 10 = 3 rep equivalent
volume_mult = 1 + 3 × 0.02 = 1.06
XP = 15 × 1.75 × 1.0 (streak) × 1.06 × 1.0 (first) = ~28 XP
```

**Сценарий 2: 2 подхода, 30+30 = 60 секунд**
```
total_duration = 60
xp_value = 60 // 10 = 6 rep equivalent
volume_mult = 1 + 6 × 0.02 = 1.12
XP = 15 × 1.75 × 1.0 × 1.12 × 1.0 = ~29 XP
Прирост от 2-го подхода: 29 - 28 = 1 XP ❌
```

**Сценарий 3: 1 подход, 30 повторений (rep-based)**
```
total_reps = 30
volume_mult = 1.4 + (30-20) × 0.01 = 1.5
XP = 15 × 1.75 × 1.0 × 1.5 × 1.0 = ~39 XP
```

**Сценарий 4: 2 подхода, 30+30 = 60 повторений**
```
total_reps = 60
volume_mult = 1.4 + (60-20) × 0.01 = 1.8
XP = 15 × 1.75 × 1.0 × 1.8 × 1.0 = ~47 XP
Прирост от 2-го подхода: 47 - 39 = 8 XP
```

## Проблема

Текущая логика суммирует все подходы и считает XP один раз для всего упражнения. Это приводит к тому, что:
- Volume multiplier применяется к общей сумме
- Каждый дополнительный подход даёт меньше XP (diminishing returns)
- Пользователь видит маленький прирост от дополнительных подходов

## Возможные решения

### Вариант 1: Считать XP для каждого подхода отдельно (рекомендуется)

```python
# Для каждого подхода:
for set_value in ex_data.sets:
    if is_timed:
        reps_value = set_value // 10
    else:
        reps_value = set_value
    
    xp_for_set = calculate_xp(
        base_xp=exercise.base_xp,
        difficulty=exercise.difficulty,
        reps=reps_value,  # Для этого подхода
        streak_days=user.current_streak,
        is_first_today=is_first_today,
    )
    total_xp += xp_for_set
```

**Преимущества:**
- Каждый подход даёт справедливый XP
- Пользователь видит прирост от каждого подхода
- Более понятная логика

**Недостатки:**
- Может давать больше XP за много подходов
- Volume multiplier будет применяться к каждому подходу отдельно

### Вариант 2: Умножить base_xp на количество повторений/секунд

```python
# base_xp - это XP за одно повторение/секунду
xp_earned = base_xp * total_reps * difficulty_mult * streak_mult * first_bonus
# volume_mult не используется или применяется по-другому
```

**Преимущества:**
- Простая логика
- Линейный рост XP

**Недостатки:**
- Нет diminishing returns
- Может давать слишком много XP

### Вариант 3: Оставить текущую логику, но улучшить volume_mult

Изменить формулу volume_mult, чтобы она давала более справедливый прирост.

## Рекомендация

**Вариант 1** - считать XP для каждого подхода отдельно. Это более справедливо и понятно для пользователя.

